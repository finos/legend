"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7942],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>m});var i=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=i.createContext({}),s=function(e){var t=i.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(u.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(n),g=a,m=c["".concat(u,".").concat(g)]||c[g]||d[g]||o;return n?i.createElement(m,r(r({ref:t},p),{},{components:n})):i.createElement(m,r({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=g;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},4613:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>u,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var i=n(8168),a=n(8587),o=(n(6540),n(5680)),r=["components"],l={},u=void 0,s={unversionedId:"community/legend-pct-howto",id:"community/legend-pct-howto",title:"legend-pct-howto",description:"Required Development Setup",source:"@site/../docs/community/legend-pct-howto.md",sourceDirName:"community",slug:"/community/legend-pct-howto",permalink:"/docs/community/legend-pct-howto",draft:!1,tags:[],version:"current",frontMatter:{}},p={},c=[{value:"Required Development Setup",id:"required-development-setup",level:3},{value:"Test your Development Setup",id:"test-your-development-setup",level:4},{value:"Native PCT Functions",id:"native-pct-functions",level:2},{value:"1. Define the: a) the Native Function Signature, and b) Reference/Spec Implementation",id:"1-define-the-a-the-native-function-signature-and-b-referencespec-implementation",level:4},{value:"Example",id:"example",level:5},{value:"Dev Envs: PureIDE (native function signature); IntelliJ (reference/spec implementation), Target runtimes for testing behavior of equivalent function (e.g. DuckDb, Snowflake)",id:"dev-envs-pureide-native-function-signature-intellij-referencespec-implementation-target-runtimes-for-testing-behavior-of-equivalent-function-eg-duckdb-snowflake",level:6},{value:"2. Native Function Development Loop",id:"2-native-function-development-loop",level:4},{value:"2.i. Start by writing a draft native function signature in pure",id:"2i-start-by-writing-a-draft-native-function-signature-in-pure",level:5},{value:"How to use PureIDE welcome.pure",id:"how-to-use-pureide-welcomepure",level:5},{value:"Dev Envs: PureIDE welcome.pure (legend-engine)",id:"dev-envs-pureide-welcomepure-legend-engine",level:6},{value:"2.ii. Determine where the signature of the PCT Function and associated tests should reside.",id:"2ii-determine-where-the-signature-of-the-pct-function-and-associated-tests-should-reside",level:5},{value:"PCT Taxonomy Conventions",id:"pct-taxonomy-conventions",level:6},{value:"Example",id:"example-1",level:5},{value:"Dev Envs: PureIDE code search (legend-engine)",id:"dev-envs-pureide-code-search-legend-engine",level:6},{value:"2.iii. Start writing some Pure Compatibility Tests (PCT) to encapsulate the understanding gained in 1., being careful to test for edge cases.",id:"2iii-start-writing-some-pure-compatibility-tests-pct-to-encapsulate-the-understanding-gained-in-1-being-careful-to-test-for-edge-cases",level:5},{value:"Example",id:"example-2",level:6},{value:"Dev Envs: PureIDE welcome.pure (legend-engine)",id:"dev-envs-pureide-welcomepure-legend-engine-1",level:6},{value:"2.iv. Write the Reference/Spec implementation",id:"2iv-write-the-referencespec-implementation",level:5},{value:"Example",id:"example-3",level:6},{value:"Dev Env: IntelliJ",id:"dev-env-intellij",level:6},{value:"2.v. Running PCTs against Native Function",id:"2v-running-pcts-against-native-function",level:5},{value:"Example Usage",id:"example-usage",level:6},{value:"Dev Envs: PureIDE welcome.pure (legend-engine)",id:"dev-envs-pureide-welcomepure-legend-engine-2",level:6},{value:"3. Target (cross-compilation) development loop",id:"3-target-cross-compilation-development-loop",level:4},{value:"3.i. PCTs and PureToTarget wiring (e.g. PureToSQL).",id:"3i-pcts-and-puretotarget-wiring-eg-puretosql",level:5},{value:"Example Target Adapter Usage",id:"example-target-adapter-usage",level:5},{value:"Example Target SQL wiring for timeBucket native function",id:"example-target-sql-wiring-for-timebucket-native-function",level:5},{value:"Dev Envs: PureIDE (legend-engine)",id:"dev-envs-pureide-legend-engine",level:6},{value:"3.ii. Native Function Registration in Handlers.java and other relevant files.",id:"3ii-native-function-registration-in-handlersjava-and-other-relevant-files",level:5},{value:"Dev Env: IntelliJ",id:"dev-env-intellij-1",level:6},{value:"3.iii. Update ExpectedFailures of PCT Targets where you have not yet implemented the function.",id:"3iii-update-expectedfailures-of-pct-targets-where-you-have-not-yet-implemented-the-function",level:5},{value:"Dev Env: IntelliJ",id:"dev-env-intellij-2",level:6},{value:"3.iv. Leverage Adapters to easily run the PCT Tests written in the Native Function Development Loop against target environments.",id:"3iv-leverage-adapters-to-easily-run-the-pct-tests-written-in-the-native-function-development-loop-against-target-environments",level:5},{value:"Dev Envs: PureIDE (legend-engine)",id:"dev-envs-pureide-legend-engine-1",level:6},{value:"4. FINAL Step: Preparing for PR",id:"4-final-step-preparing-for-pr",level:4},{value:"Example command to build with threads",id:"example-command-to-build-with-threads",level:5},{value:"Example PRs",id:"example-prs",level:4},{value:"New Native Function",id:"new-native-function",level:5},{value:"Conversion of Existing Function to PCT",id:"conversion-of-existing-function-to-pct",level:5},{value:"Legend Platform Conventions",id:"legend-platform-conventions",level:2},{value:"Style",id:"style",level:3},{value:"Practices",id:"practices",level:3}],d={toc:c},g="wrapper";function m(e){var t=e.components,n=(0,a.A)(e,r);return(0,o.yg)(g,(0,i.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h3",{id:"required-development-setup"},"Required Development Setup"),(0,o.yg)("p",null,"Set up develoment environment for ",(0,o.yg)("em",{parentName:"p"},"legend-engine"),": "),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"https://github.com/finos/legend-engine/blob/master/README.md#development-setup"},"https://github.com/finos/legend-engine/blob/master/README.md#development-setup"))),(0,o.yg)("h4",{id:"test-your-development-setup"},"Test your Development Setup"),(0,o.yg)("p",null,"Once you have built the repo, try running Pure code"),(0,o.yg)("p",null,"Provided with PureIDE is a ",(0,o.yg)("inlineCode",{parentName:"p"},"welcome.pure")," file. F9 within this file to execute pure code."),(0,o.yg)("h1",{id:"pct-contribution-steps"},"PCT Contribution Steps"),(0,o.yg)("p",null,(0,o.yg)("em",{parentName:"p"},"Awareness of the dev environment in which each step of the development loop occurs is key to maintaining velocity.")),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Language"),(0,o.yg)("th",{parentName:"tr",align:null},"Development Environment"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Pure"),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"https://github.com/finos/legend-engine/blob/master/README.md#starting-pure-ide"},"PureIDE"))),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Java"),(0,o.yg)("td",{parentName:"tr",align:null},"IntelliJ")))),(0,o.yg)("p",null,"The Pure Runtime cross-compiles ",(0,o.yg)("em",{parentName:"p"},"Pure native functions")," to multiple targets. Native functions have a reference implementation in the Pure Runtime, and are cross-compiled by the Pure Runtime to ",(0,o.yg)("em",{parentName:"p"},"equivalent")," implementations in target runtimes. "),(0,o.yg)("p",null,"Pure has two code paths for cross-compilation\n1) ",(0,o.yg)("em",{parentName:"p"},"Interpreted")," - Pure code is compiled on the fly (useful for interactive dev).\n2)  ",(0,o.yg)("em",{parentName:"p"},"Compiled")," - Pure code has already been compiled to a jar (useful for prod)."),(0,o.yg)("p",null,'Note that PCT Function can be Pure-only (implemented in Pure), or "Native" (implemented in Java). The below steps cover Native Functions, but Pure-only PCT should follow the same principles and similar dev loops.'),(0,o.yg)("h2",{id:"native-pct-functions"},"Native PCT Functions"),(0,o.yg)("h4",{id:"1-define-the-a-the-native-function-signature-and-b-referencespec-implementation"},"1. Define the: a) the Native Function Signature, and b) Reference/Spec Implementation"),(0,o.yg)("p",null,"The ",(0,o.yg)("em",{parentName:"p"},"Pure Reference/Spec Implementation")," encapsulates the platform-specific expectations for the behavior of the function; it is implemented as a ",(0,o.yg)("em",{parentName:"p"},"Native Function"),". It executes natively in the Pure Runtime and thus is written in Java. "),(0,o.yg)("p",null,"When defining a Native Function Signature, it is ",(0,o.yg)("strong",{parentName:"p"},(0,o.yg)("em",{parentName:"strong"},"important to compare the equivalent function on at least 2 targets")),". A minimum of 2 targets helps to ensure our function signature and reference implementation is properly abstracted."),(0,o.yg)("h5",{id:"example"},"Example"),(0,o.yg)("p",null,"These two queries will not yield equivalent results. Further, you can see that the parameters they accept are different."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},"// DuckDb\nSelect time_bucket(Interval '2 Day', timestamp '2024-01-31 00:32:34');\n// results in \n2024-01-31 00:00:00\n\n// Snowflake\nSELECT TIME_SLICE(TIMESTAMP_FROM_PARTS(2024, 01, 31, 00, 32, 34), 2, 'DAY', 'START')\n// results in\n2024-01-30 00:00:00.000\n")),(0,o.yg)("p",null,"Understanding the minimal common elements to determine the appropriate Native Function signature is key. Consider the set of parameters and input/output required for cross-platform compilation capabilities."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},"// for the above, the native function signature we ended up with was:\nnative function\n    <<PCT.function>>\n    {\n         doc.doc='calculates a time bucket for DateTime, where the bucket is of size quantity unit (e.g. 5 Hour). Uses unix Epoch as the origin for the calculation.'\n    }\n    meta::pure::functions::date::timeBucket(date:DateTime[1], quantity:Integer[1], unit:DurationUnit[1]):DateTime[1];\n\n//notice how we have a docstring as part of the function signature\n")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Important: docstrings are Required")),(0,o.yg)("p",null,"In this example, we only needed one function signature. A native function can have more than one signature. ",(0,o.yg)("strong",{parentName:"p"},"All signatures for the same native function should be written in the same file.")," E.g. the above native function signature and its associated PCT functions exist in ",(0,o.yg)("em",{parentName:"p"},"timeBucket.pure"),"."),(0,o.yg)("h6",{id:"dev-envs-pureide-native-function-signature-intellij-referencespec-implementation-target-runtimes-for-testing-behavior-of-equivalent-function-eg-duckdb-snowflake"},"Dev Envs: PureIDE (native function signature); IntelliJ (reference/spec implementation), Target runtimes for testing behavior of equivalent function (e.g. DuckDb, Snowflake)"),(0,o.yg)("h4",{id:"2-native-function-development-loop"},"2. Native Function Development Loop"),(0,o.yg)("h5",{id:"2i-start-by-writing-a-draft-native-function-signature-in-pure"},"2.i. Start by writing a draft native function signature in pure"),(0,o.yg)("p",null,"To play with pure code, use welcome.pure in PureIDE."),(0,o.yg)("h5",{id:"how-to-use-pureide-welcomepure"},"How to use PureIDE welcome.pure"),(0,o.yg)("p",null,"Dev pure code can be written in the go():Any","[*]"," function of welcome.pure. In PureIDE, hitting F9 will execute the code."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},"function go():Any[*]\n{\n    // Your pure code here\n    \n    // E.g. this is an example function definition and call\n    function meta::functions::myScratchFn(myString:String[1]):String[2]\n    {\n        println('123');\n        let myStrList = [$myString, $myString];\n        println($myStrList);\n        $myStrList;\n    }\n    let myString = 'abc';\n    meta::functions::myScratchFn($myString);\n    \n    // the below call would fail due to missing wiring\n    meta::pure::functions::unclassified::scratch::myScratchFn($myString);\n}\n")),(0,o.yg)("h6",{id:"dev-envs-pureide-welcomepure-legend-engine"},"Dev Envs: PureIDE welcome.pure (legend-engine)"),(0,o.yg)("h5",{id:"2ii-determine-where-the-signature-of-the-pct-function-and-associated-tests-should-reside"},"2.ii. Determine where the signature of the PCT Function and associated tests should reside."),(0,o.yg)("p",null,"Once you know how to run pure code, begin your development loop. Leverage the PCT Taxonomy conventions and the results of weekly Taxonomy review sessions to determine the repo/package in which to put your pure code."),(0,o.yg)("h6",{id:"pct-taxonomy-conventions"},"PCT Taxonomy Conventions"),(0,o.yg)("p",null,"Below describes the categories of PCT functions. Most of the functions you add will end up in Standard. However, as a first step, you should add them in ",(0,o.yg)("strong",{parentName:"p"},"legend-engine-pure-code-functions-unclassified")," . Later on, a legend-engine PCT SME will look to determine the correct place for the function. "),(0,o.yg)("p",null,"The structure of *.pure files containing Platform Functions has been harmonized to reflect the four categories of Pure Functions:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Grammar (legend-pure) - functions needed for the grammar of the platform. Should almost never be modified. If needed, consult with a Legend CODEOWNER."),(0,o.yg)("li",{parentName:"ol"},"Essential (legend-pure) - foundational functions required for running tests int he platform (e.g. assert, eq). Should almost never be modified. If needed, consult with a Legend CODEOWNER."),(0,o.yg)("li",{parentName:"ol"},"Standard (legend-engine) - majority of platform functions will fall into this category"),(0,o.yg)("li",{parentName:"ol"},"Relation (legend-engine) - platform functions specific to operating on relations (e.g. join)")),(0,o.yg)("p",null,"Note that ",(0,o.yg)("em",{parentName:"p"},"pure package")," naming will eventually be harmonized to a hierarchy similar to the directory structure of ",(0,o.yg)("em",{parentName:"p"},"legend-pure"),' "essential" functions. However, for now, please consult with an SME to confirm the proposed package/naming for your PCT function. '),(0,o.yg)("h5",{id:"example-1"},"Example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},"// PCT Function Signature containing docstring; note that it specifies the expected params, output, and multiplicity\nnative function\n    <<PCT.function>>\n    {\n         doc.doc='calculates a time bucket for DateTime, where the bucket is of size quantity unit (e.g. 5 Hour). Uses unix Epoch as the origin for the calculation.'\n    }\n    meta::pure::functions::date::timeBucket(date:DateTime[1], quantity:Integer[1], unit:DurationUnit[1]):DateTime[1];\n\n// this is a \"standard\" function and so its signature and implemention live in this package:\nlegend-engine-core/legend-engine-core-pure/legend-engine-pure-code-functions-standard/\n\n// in the above function signature, you can see the current pure package is\nmeta::pure::functions::date\n\n// filesystem taxonomy of timeBucket.pure file containing the PCT function (in legend-engine)\ncore_functions_standard/date/operation/timeBucket.pure\n\n// based on the filesystem taxonomy, ideally the package would be named thusly:\nmeta::pure::functions::date::operation\n\n//however, in this instance we kept the existing pure package taxonomy for dates - until the taxonomy has been upgraded, please speak to an SME to double check your proposed package/naming\n")),(0,o.yg)("h6",{id:"dev-envs-pureide-code-search-legend-engine"},"Dev Envs: PureIDE code search (legend-engine)"),(0,o.yg)("h5",{id:"2iii-start-writing-some-pure-compatibility-tests-pct-to-encapsulate-the-understanding-gained-in-1-being-careful-to-test-for-edge-cases"},"2.iii. Start writing some Pure Compatibility Tests (PCT) to encapsulate the understanding gained in 1., being careful to test for edge cases."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"PCT Tests should be written in the same file as your native function signature")),(0,o.yg)("p",null,"Note: test package naming is important (examples below)."),(0,o.yg)("h6",{id:"example-2"},"Example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},'// Example Good package name: a test package named like so\nmeta::pure::functions::date::tests::timeBucket\n\n// can be registered in expectedFailuers with one line for unsupported targets\npack("meta::pure::functions::date::tests::timeBucket", "\\"meta::pure::functions::date::timeBucket_DateTime_1__Integer_1__DurationUnit_1__DateTime_1_ is not supported yet!\\"")\n\n// Example Bad package name: a test package named like so can only be registered in expectedFailures one by one\nmeta::pure::functions::date::tests\n')),(0,o.yg)("h6",{id:"dev-envs-pureide-welcomepure-legend-engine-1"},"Dev Envs: PureIDE welcome.pure (legend-engine)"),(0,o.yg)("h5",{id:"2iv-write-the-referencespec-implementation"},"2.iv. Write the Reference/Spec implementation"),(0,o.yg)("p",null,"Your native function implementation (Java code) will be split across 3 modules in the taxonomy package:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"-compiled- the compiled module of the function taxonomy will contain the wiring needed by the Pure Runtime to ",(0,o.yg)("em",{parentName:"li"},"generate the compiled")," java code"),(0,o.yg)("li",{parentName:"ol"},"-interpreted- the interpreted module of the function taxonomy will contain the wiring needed for Pure Runtime to ",(0,o.yg)("em",{parentName:"li"},"interpret")," and compile pure code on the fly"),(0,o.yg)("li",{parentName:"ol"},"-shared- the class containing the code common to 1 and 2 should be put in this module. These utility classes help avoid duplication.")),(0,o.yg)("p",null,"Note that you can wire the function in even if it hasn't been fully written. Use the helpers described in step 3.i. to test out the wiring of your native function. "),(0,o.yg)("h6",{id:"example-3"},"Example"),(0,o.yg)("p",null,"see ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/finos/legend-engine/pull/3491/files#diff-6fdf9132208dc083a35c61ff70294ea2eb3b51e12f167a89f69c4a66bc741c6a"},"TimeBucketShared in the example PR"),"."),(0,o.yg)("h6",{id:"dev-env-intellij"},"Dev Env: IntelliJ"),(0,o.yg)("h5",{id:"2v-running-pcts-against-native-function"},"2.v. Running PCTs against Native Function"),(0,o.yg)("p",null,"Once the native function is wired across the compiled and interpreted paths, you can loop and iterate to refine the signature, implementation, and tests, using the ",(0,o.yg)("em",{parentName:"p"},"InMemory PCT Adapter"),". PCT Adapters are functions that enable the cross-compilation and evaluation of PCT functions on target environments. The InMemory adapter does a pass-through to the Pure Runtime and is useful for running the native reference/spec implementation."),(0,o.yg)("h6",{id:"example-usage"},"Example Usage"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},'let inmemoryadapter = meta::pure::test::pct::testAdapterForInMemoryExecution_Function_1__X_o_;\n\n// runs the PCT "testTimeBucketSeconds" against Reference Implementation (eval in pure runtime)\nmeta::pure::functions::date::tests::testTimeBucketSeconds($inmemoryadapter);\n')),(0,o.yg)("h6",{id:"dev-envs-pureide-welcomepure-legend-engine-2"},"Dev Envs: PureIDE welcome.pure (legend-engine)"),(0,o.yg)("h4",{id:"3-target-cross-compilation-development-loop"},"3. Target (cross-compilation) development loop"),(0,o.yg)("p",null,"Once you have completed the Native Function development loop, it is time to wire your native function to cross-compile to the target environments "),(0,o.yg)("h5",{id:"3i-pcts-and-puretotarget-wiring-eg-puretosql"},"3.i. PCTs and PureToTarget wiring (e.g. PureToSQL)."),(0,o.yg)("p",null,"PCT are useful for testing your wiring, as they are evaluated in the context of the target platform. The assert happens in the Pure Runtime, but the assertion is over the result of an eval on the target platform (i.e. that the cross-compilation behaves as the platform expects)."),(0,o.yg)("p",null,"PCT Adapters are functions that enable the cross-compilation of PCT to target environments. To find a current list of adapters, search for the phrase ",(0,o.yg)("inlineCode",{parentName:"p"},"<<PCT.adapter>>")," in PureIDE. Notes on selected adapter are below:"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Target"),(0,o.yg)("th",{parentName:"tr",align:null},"Notes"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Snowflake"),(0,o.yg)("td",{parentName:"tr",align:null},"Snowflake integration requires connection to your Snowflake account. Look at the code in SnowflakeTestConnectionIntegration and set up neded env vars for accessing snowflake in order to run this adapter.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},"Java Platform Binding"),(0,o.yg)("td",{parentName:"tr",align:null},"Legend platform has the capability of generating java code from pure code. Think of it as the equivalent of pureToSQL but it's pureToJava instead. This is distinct from Pure Runtime java code. This is code generated by the Pure Runtime itself to encapsulate queries meant to run on a Java Target Environment.")))),(0,o.yg)("h5",{id:"example-target-adapter-usage"},"Example Target Adapter Usage"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},'let duckdbadapter = meta::relational::tests::pct::testAdapterForRelationalWithDuckDBExecution_Function_1__X_o_;\n  \n// runs the PCT "testTimeBucketSeconds" against DuckDb (eval on DuckDb)\nmeta::pure::functions::date::tests::testTimeBucketSeconds($duckdbadapter);\n')),(0,o.yg)("h5",{id:"example-target-sql-wiring-for-timebucket-native-function"},"Example Target SQL wiring for timeBucket native function"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-Java"},"// PureToDuckDb - this code was added in duckdbExtension.pure\ndynaFnToSql('timeBucket',             $allStates,            ^ToSql(format='cast(time_bucket(%s) as timestamp_s)', transform={p:String[3] | constructIntervalFunction($p->at(2), $p->at(1)) + ', ' + $p->at(0) + ', ' + constructTimeBucketOffset($p->at(2))})),\n\n// DuckDb uses a different origin for calculation of timebuckets; this offset helps to standardize toward unix epoch as origin and\n// the offset for intervals < WEEK are set to align with Snowflake's methodology, as opposed to that which is outlined in DuckDb\n// ref: https://github.com/duckdb/duckdb/blob/68bd4a5277430245e3d9edf1abbb9813520a3dff/extension/core_functions/scalar/date/time_bucket.cpp#L18\nfunction meta::relational::functions::sqlQueryToString::duckDB::constructTimeBucketOffset(unit:String[1]):String[1]\n{\n  let unitWithoutQuotes = $unit->removeQuotesIfExist();\n  let ISOMondayEpochOffset = 'timestamp \\'1969-12-29 00:00:00\\'';\n  let EpochOffset = 'timestamp \\'1970-01-01 00:00:00\\'';\n\n  let offset = [\n      pair(DurationUnit.YEARS->toString(), $EpochOffset),\n      pair(DurationUnit.MONTHS->toString(), $EpochOffset),\n      pair(DurationUnit.WEEKS->toString(), $ISOMondayEpochOffset),\n      pair(DurationUnit.DAYS->toString(), $EpochOffset),\n      pair(DurationUnit.HOURS->toString(), $EpochOffset),\n      pair(DurationUnit.MINUTES->toString(), $EpochOffset),\n      pair(DurationUnit.SECONDS->toString(), $EpochOffset)\n   ]->filter(p | $p.first == $unitWithoutQuotes).second->toOne('Unit not found: ' + $unitWithoutQuotes);\n}\n\n//------------------------\n// PureToSnowflake - this code was added in snowflakeExtension.pure\ndynaFnToSql('timeBucket',             $allStates,            ^ToSql(format='TIME_SLICE(%s)', transform={p:String[3]|$p->at(0) + ', ' + constructInterval($p->at(2), $p->at(1))})),\n\nfunction meta::relational::functions::sqlQueryToString::snowflake::constructInterval(unit:String[1], i:String[1]):String[1]\n{\n   let unitWithoutQuotes = $unit->removeQuotesIfExist();\n\n   let interval= [\n      pair(DurationUnit.YEARS->toString(), '\\'YEAR\\''),\n      pair(DurationUnit.MONTHS->toString(), '\\'MONTH\\''),\n      pair(DurationUnit.WEEKS->toString(), '\\'WEEK\\''),\n      pair(DurationUnit.DAYS->toString(), '\\'DAY\\''),\n      pair(DurationUnit.HOURS->toString(), '\\'HOUR\\''),\n      pair(DurationUnit.MINUTES->toString(), '\\'MINUTE\\''),\n      pair(DurationUnit.SECONDS->toString(), '\\'SECOND\\'')\n   ]->filter(p | $p.first == $unitWithoutQuotes).second->toOne('Unit not supported: ' + $unitWithoutQuotes);\n\n   $i + ', ' + $interval;\n}\n")),(0,o.yg)("h6",{id:"dev-envs-pureide-legend-engine"},"Dev Envs: PureIDE (legend-engine)"),(0,o.yg)("h5",{id:"3ii-native-function-registration-in-handlersjava-and-other-relevant-files"},"3.ii. Native Function Registration in Handlers.java and other relevant files."),(0,o.yg)("p",null,"To find the places where you may need to wire in the function, you should Ctrl+Shift+F (IntelliJ) to see how similar functions were wired."),(0,o.yg)("h6",{id:"dev-env-intellij-1"},"Dev Env: IntelliJ"),(0,o.yg)("h5",{id:"3iii-update-expectedfailures-of-pct-targets-where-you-have-not-yet-implemented-the-function"},"3.iii. Update ExpectedFailures of PCT Targets where you have not yet implemented the function."),(0,o.yg)("p",null,"In legend-engine, Ctrl+Shift+N (IntelliJ file-search) in IntelliJ for ",(0,o.yg)("inlineCode",{parentName:"p"},"Test_*_PCT")," to find the relevant files of targets where you will need to register your expectedFailures."),(0,o.yg)("p",null,"You can build these modules individually to run the tests - avoid rebuilding the entire project."),(0,o.yg)("h6",{id:"dev-env-intellij-2"},"Dev Env: IntelliJ"),(0,o.yg)("h5",{id:"3iv-leverage-adapters-to-easily-run-the-pct-tests-written-in-the-native-function-development-loop-against-target-environments"},"3.iv. Leverage Adapters to easily run the PCT Tests written in the Native Function Development Loop against target environments."),(0,o.yg)("p",null,"You may need to loop between this step and earlier steps to improve what you wrote previously."),(0,o.yg)("h6",{id:"dev-envs-pureide-legend-engine-1"},"Dev Envs: PureIDE (legend-engine)"),(0,o.yg)("hr",null),(0,o.yg)("h4",{id:"4-final-step-preparing-for-pr"},"4. FINAL Step: Preparing for PR"),(0,o.yg)("p",null,"This should be the Final Step and should only happen Once. ",(0,o.yg)("strong",{parentName:"p"},(0,o.yg)("em",{parentName:"strong"},"Maven builds are expensive and should be avoided until absolutely necessary.")),"\nRun mvn clean install with tests in order to identify any potential tests that could fail due to your new module"),(0,o.yg)("h5",{id:"example-command-to-build-with-threads"},"Example command to build with threads"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"mvn clean install -T 3\n")),(0,o.yg)("h4",{id:"example-prs"},"Example PRs"),(0,o.yg)("h5",{id:"new-native-function"},"New Native Function"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://github.com/finos/legend-engine/pull/3491/files"},"timeBucket")),(0,o.yg)("h5",{id:"conversion-of-existing-function-to-pct"},"Conversion of Existing Function to PCT"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://github.com/finos/legend-engine/pull/3424/files#diff-00c42b86368a6fcd15328a4041dbacdd70df22b3ecab95e3c75138af224c3f2e"},"https://github.com/finos/legend-engine/pull/3424/files#diff-00c42b86368a6fcd15328a4041dbacdd70df22b3ecab95e3c75138af224c3f2e")),(0,o.yg)("hr",null),(0,o.yg)("h1",{id:"appendix"},"Appendix"),(0,o.yg)("h2",{id:"legend-platform-conventions"},"Legend Platform Conventions"),(0,o.yg)("p",null,"Conventions ensure that we can achieve ",(0,o.yg)("strong",{parentName:"p"},"Goal - a clean (minimal) and transparent platform api"),"."),(0,o.yg)("p",null,"It is critical that utmost care is taken when deciding on:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Function Signature"),(0,o.yg)("li",{parentName:"ul"},"Code Location"),(0,o.yg)("li",{parentName:"ul"},"Naming/Style")),(0,o.yg)("h3",{id:"style"},"Style"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"One file per PCT Function",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"All Function Signatures for the PCT Function belong in the same file"),(0,o.yg)("li",{parentName:"ul"},"All PCT tests for the PCT function belong in the same file"))),(0,o.yg)("li",{parentName:"ul"},"package names are all lower-case"),(0,o.yg)("li",{parentName:"ul"},"function names are camelCase, with the first letter lower-case"),(0,o.yg)("li",{parentName:"ul"},"function signatures ",(0,o.yg)("strong",{parentName:"li"},"must have docstring (doc.doc)"))),(0,o.yg)("h3",{id:"practices"},"Practices"),(0,o.yg)("p",null,"PCT measure the level of cross-target support for a given Platform Function. When contributing to PCT on Legend, keep this preference order in mind:"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"PCT Passed(Green) > Failed PCT with Good Error Message > Failed PCT")),(0,o.yg)("p",null,(0,o.yg)("em",{parentName:"p"},"One key priority is to improve error messages on the platform - Good Error Messages are important.")),(0,o.yg)("p",null,"Note: It is highly unlikely you will need to make changes to existing reference specs/implementations. If you feel the need, contact a CODEOWNER on your proposed change."))}m.isMDXComponent=!0}}]);